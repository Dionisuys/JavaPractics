import java.util.Arrays;

class Solution {

    /*Метод, возвращающий минимально возможное значение максимального элемента
    массива nums после выполнения некоторого количества операций*/
    public static int minimizeArrayValue(int[] nums) {

        /*Нахожу начальное значение минимального и максимального элемента,
        и устанавливаю результат равным первому элементу массива nums*/
        int minValue = nums[0];
        int maxValue = Arrays.stream(nums).max().orElse(nums[0]);
        int result = nums[0];

        /*Делаю бинарный поиск для определения минимально возможного значения
        максимального элемента*/
        while (minValue <= maxValue) {
            // Вычисляю среднее значение, округляя вниз до целочисленного значения
            long midValue = (minValue + maxValue) / 2;
            /*Если значение среднего элемента подходит, то устанавливаем его в
            качестве результата и продолжаю поиск с меньшими значениями*/
            if (isNumberSuitable(nums, (int) midValue)) {
                result = (int) midValue;
                maxValue = (int) (midValue - 1);
                /*Если значение среднего элемента не подходит, то продолжаю
                поиск с большими значениями*/
            } else {
                minValue = (int) (midValue + 1);
            }
        }
        // Возвращаю минимально возможное значение максимального элемента массива nums
        return result;
    }

    /*Метод, который проверяет, можно ли получить массив nums, применяя
    описанные операции, для некоторого значения value*/
    private static boolean isNumberSuitable(int[] nums, int value) {
        /*debt - переменная, которая будет хранить суммарное количество
        вычитаемых единиц в каждой операции*/
        long debt = 0;
        //Прохожу по всем элементам массива nums справа налево
        for (int i = nums.length - 1; i >= 0; i--) {
            /*Если текущий элемент больше значения value, то увеличиваю debt
            на разницу между текущим элементом и значением value*/
            if (nums[i] > value) {
                debt += nums[i] - value;
            }
            /*Если текущий элемент меньше значения value и debt больше нуля, то
            вычитаю минимум между debt и разницей между значением value и
            текущим элементом*/
            if (nums[i] < value && debt > 0) {
                debt -= value - nums[i];
                // Если debt становится отрицательным, то устанавливаю его равным нулю
                if (debt < 0) {
                    debt = 0;
                }
            }
        }
        // Возвращаю true, если debt равен нулю, и false в противном случае
        return debt == 0;
    }
}